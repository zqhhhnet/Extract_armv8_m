# 使用

### 1. 输入

​	如所要验证的程序是：

```
VMOV Q0, #A
VMOV Q1, #B
VMAX.S16 Q2, Q0, Q1
```

​	且对应该程序的前置条件为：

​		A是Q0对应的元素的变量，B是Q1对应的元素的变量，当Q0和Q1中元素的数据类型为带符号的16位时，则需要以变量A和B为开头分别设定Q0、Q1中每个元素的范围。如下，以带符号的16位长度数据类型为例，元素从第1个到第8个对应的元素变量命名方式：

| 元素对应的变量 |    变量对应的范围    |
| :------------: | :------------------: |
|      A00       | -2^15 <= A00 < 2^14  |
|      A01       | -2^12 <= A01 <= 2^13 |
|      A02       |  -2^11 < A02 < 2^15  |
|      A03       | -2^12 <= A03 < 2^14  |
|      A04       |  -2^1 <= A04 < 2^10  |
|      A05       |  -2^6 <= A05 < 2^7   |
|      A06       |    0 <= A06 < 2^2    |
|      A07       |    5 <= A07 < 2^9    |
|      B00       |   12 <= B00 < 2^4    |
|      B01       |   -23 <= B01 < 2^8   |
|      B02       |   -64 <= B02 < 2^4   |
|      B03       |  -543 <= B03 < 2^4   |
|      B04       |   -26 <= B04 < 2^4   |
|      B05       |  -123 <= B05 < 2^4   |
|      B06       |   23 <= B06 < 2^13   |
|      B07       |    2 <= B07 < 2^4    |

​		命名规则为，以向量寄存器对应的元素变量为开头，如Q0对应的‘A’，当所要验证的数据类型为16位时，则按照元素从低（0）到高（7）设定8个元素的范围，如第0个对应 “A00”，第1个对应“A01”，第7个对应“A07”。

​		因此，**元素命名规则为：**

| 位长度 | 元素变量命名 （如向量寄存器对应变量为A，n为向量寄存器中第n个元素） |
| ------ | ------------------------------------------------------------ |
| 8      | A00n                                                         |
| 16     | A0n                                                          |
| 32     | An                                                           |

即以‘’、‘0’、‘00’分别作为32、16、8位的隔离。



将以上程序和条件用以下形式构成文件作为输入：

```
start:
	VMOV Q0, #A
	VMOV Q1, #B
	VMAX.S16 Q2, Q0, Q1
end

preCond:
	0 < A < 2^32
	0 < B < 2^32
	-2^15 <= A00 < 2^14
	-2^12 <= A01 <= 2^13
	-2^11 < A02 < 2^15
	-2^12 <= A03 < 2^14
	-2^1 <= A04 < 2^10
	-2^6 <= A05 < 2^7
	0 <= A06 < 2^2
	5 <= A07 < 2^9
	12 <= B00 < 2^4
	-23 <= B01 < 2^8
	-64 <= B02 < 2^4
	-543 <= B03 < 2^5
	-26 <= B04 < 2^4
	-123 <= B05 < 2^6
	23 <= B06 < 2^13
	2 <= B07 < 2^4
	
```

其中“start:”与“end”之间为所要验证的程序，“preCond:”之后的为设定的前置条件。其中“0 < A < 2^32”与"0 < B < 2^32"作为将A、B初始化到前置条件Map中存储起来，当检索到指令中包含变量A、B时，将从Map中获取A、B的信息然后根据数据类型获取向量寄存器中元素的范围，即“0 < A < 2^32”与"0 < B < 2^32”是声明语句，其中的范围不影响实际验证，真正影响验证的是元素范围。



### 2.验证命令：

运行：

```
./scripts/proveScript.sh  [options] <file>
```

​	options:

​		--file	 					输入，即程序与前置条件文件

​		--smt-prelude		SMT预备处理文件，对应   “KFramework_ROOT_PATH/k-distribution/include/z3/basic.smt2”，其中KFramework_ROOT_PATH为安装的KFramework根目录路径.

​		如1中输入文件名为 “prove-example.txt”，则输入以下命令

```
./scripts/proveScript.sh --file prove-example.txt --smt-prelude ~/KFramework_ROOT_PATH/k-distribution/include/z3/basic.smt2
```

其中验证脚本为scripts文件中的proveScript.sh。

### 3.安装

​	只需安装好对应版本的K Framework，调用脚本即可。

### 4.例子

​	prove_exp中包含验证的例子。