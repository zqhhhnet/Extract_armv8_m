rule <k> inkeys ( X:MyId in_keys ( .Map  ) ) => . </k>
rule <k> inkeys ( Y:MyId in_keys ( M:Map ) ) => . </k> requires Y in_keys(M)
rule <k> inkeys ( Y:MyId in_keys ( M:Map ) ) => . </k> requires notBool Y in_keys(M)
rule <k> inkeys ( X:MyId in_keys ( M:Map X      |-> 0 ) ) => . </k>
rule <k> inkeys ( Y:MyId in_keys ( M:Map X:MyId |-> 0 ) ) => . </k>
rule <k> inkeys ( Y:MyId in_keys ( M:Map X:MyId |-> 0 ) ) => . </k> requires Y in_keys(M)
rule <k> inkeys ( Y:MyId in_keys ( M:Map X:MyId |-> 0 ) ) => . </k> requires notBool Y in_keys(M)
rule <k> inkeys ( X:MyId in_keys ( Z:MyId |-> 1 M:Map X      |-> 0 ) ) => . </k>
rule <k> inkeys ( Y:MyId in_keys ( Z:MyId |-> 1 M:Map X:MyId |-> 0 ) ) => . </k>
rule <k> inkeys ( Y:MyId in_keys ( Z:MyId |-> 1 M:Map X:MyId |-> 0 ) ) => . </k> requires Y in_keys(M)
rule <k> inkeys ( Y:MyId in_keys ( Z:MyId |-> 1 M:Map X:MyId |-> 0 ) ) => . </k> requires notBool Y in_keys(M)
rule <k> inkeys ( X:MyId in_keys ( M:Map [ X      <- 0 ] ) ) => . </k>
rule <k> inkeys ( Y:MyId in_keys ( M:Map [ X:MyId <- 0 ] ) ) => . </k>
rule <k> inkeys ( Y:MyId in_keys ( M:Map [ X:MyId <- 0 ] ) ) => . </k> requires Y in_keys(M)
rule <k> inkeys ( Y:MyId in_keys ( M:Map [ X:MyId <- 0 ] ) ) => . </k> requires notBool Y in_keys(M)
rule <k> inkeys ( X:MyId in_keys ( M:Map [ Z:MyId <- 1 ] [ X      <- 0 ] ) ) => . </k>
rule <k> inkeys ( Y:MyId in_keys ( M:Map [ Z:MyId <- 1 ] [ X:MyId <- 0 ] ) ) => . </k>
rule <k> inkeys ( Y:MyId in_keys ( M:Map [ Z:MyId <- 1 ] [ X:MyId <- 0 ] ) ) => . </k> requires Y in_keys(M)
rule <k> inkeys ( Y:MyId in_keys ( M:Map [ Z:MyId <- 1 ] [ X:MyId <- 0 ] ) ) => . </k> requires notBool Y in_keys(M)
